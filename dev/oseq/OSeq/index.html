<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>OSeq (oseq.OSeq)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">oseq</a> &#x00BB; OSeq</nav><header class="odoc-preamble"><h1>Module <code><span>OSeq</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#oseq:-functional-iterators">OSeq: Functional Iterators</a><ul><li><a href="#basic-combinators">Basic combinators</a></li><li><a href="#multiple-iterators">Multiple iterators</a></li><li><a href="#complex-combinators">Complex combinators</a></li><li><a href="#relational-combinators">Relational combinators</a></li><li><a href="#basic-conversion-functions">Basic conversion functions</a></li><li><a href="#easy-interface-to-produce-iterators">Easy interface to Produce Iterators</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="oseq:-functional-iterators"><a href="#oseq:-functional-iterators" class="anchor"></a>OSeq: Functional Iterators</h2><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="xref-unresolved">Stdlib</span>.Seq <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <span class="xref-unresolved">node</span></span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.node</span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>!'a t</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-node">node</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-node" class="anchored"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">and</span> <span>!'a node</span></span><span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.node</span></span><span> = </span></code><table><tr id="type-node.Nil" class="anchored"><td class="def variant constructor"><a href="#type-node.Nil" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil</span></span></code></td></tr><tr id="type-node.Cons" class="anchored"><td class="def variant constructor"><a href="#type-node.Cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></td></tr></table></div></div></details></div><div class="odoc-spec"><div class="spec type" id="type-seq" class="anchored"><a href="#type-seq" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a seq</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-iter" class="anchored"><a href="#type-iter" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a iter</span></span><span> = <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-gen" class="anchored"><a href="#type-gen" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a gen</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-equal" class="anchored"><a href="#type-equal" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a equal</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-ord" class="anchored"><a href="#type-ord" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ord</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-printer" class="anchored"><a href="#type-printer" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a printer</span></span><span> = <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Empty iterator, with no elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>One-element iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Repeat same element endlessly</p></div></div><div class="odoc-spec"><div class="spec value" id="val-head_exn" class="anchored"><a href="#val-head_exn" class="anchor"></a><code><span><span class="keyword">val</span> head_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Returns first element, or fails.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty sequence</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-tail_exn" class="anchored"><a href="#val-tail_exn" class="anchor"></a><code><span><span class="keyword">val</span> tail_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns list without its first element, or fails.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty sequence</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cycle" class="anchored"><a href="#val-cycle" class="anchor"></a><code><span><span class="keyword">val</span> cycle : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cycle through the iterator infinitely. The iterator shouldn't be empty.</p><pre><code># OSeq.(cycle (1--3) |&gt; take 10 |&gt; to_list);;
- : int list = [1; 2; 3; 1; 2; 3; 1; 2; 3; 1]</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-iterate" class="anchored"><a href="#val-iterate" class="anchor"></a><code><span><span class="keyword">val</span> iterate : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>iterate x f</code> is <code>[x; f x; f (f x); f (f (f x)); ...]</code>.</p><pre><code># OSeq.(iterate 0 succ |&gt; take 10 |&gt; to_list);;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Dual of <a href="#val-fold"><code>fold</code></a>, with a deconstructing operation. It keeps on unfolding the <code>'b</code> value into a new <code>'b</code>, and a <code>'a</code> which is yielded, until <code>None</code> is returned.</p><pre><code># OSeq.(unfold (fun x -&gt; if x&lt;5 then Some (string_of_int x, x+1) else None) 0 |&gt; to_list);;
- : string list = [&quot;0&quot;; &quot;1&quot;; &quot;2&quot;; &quot;3&quot;; &quot;4&quot;]</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-repeatedly" class="anchored"><a href="#val-repeatedly" class="anchor"></a><code><span><span class="keyword">val</span> repeatedly : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Call the same function an infinite number of times (useful for instance if the function is a random iterator).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>?n:int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Calls the function, starting from 0, on increasing indices. If <code>n</code> is provided and is a positive int, iteration will stop at the limit (excluded). For instance <code>init ~n:4 (fun x-&gt;x)</code> will yield 0, 1, 2, and 3.</p></div></div><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic combinators</h3><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check whether the iterator is empty. Pops an element, if any</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Fold on the iterator, tail-recursively.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Alias to <a href="#val-fold"><code>fold</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Fold on the iterator, tail-recursively.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-reduce" class="anchored"><a href="#val-reduce" class="anchor"></a><code><span><span class="keyword">val</span> reduce : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold on non-empty iterators.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty iterator</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-fold"><code>fold</code></a>, but keeping successive values of the accumulator.</p><pre><code># OSeq.(scan (+) 0 (1--5) |&gt; to_list);;
- : int list = [0; 1; 3; 6; 10; 15]</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold_scan" class="anchored"><a href="#val-unfold_scan" class="anchor"></a><code><span><span class="keyword">val</span> unfold_scan : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A mix of <a href="#val-unfold"><code>unfold</code></a> and <a href="#val-scan"><code>scan</code></a>. The current state is combined with the current element to produce a new state, and an output value of type 'c.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on the iterator .</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on elements with their index in the iterator, from 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Length of an iterator (linear time).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy map. No iteration is performed now, the function will be called when the result is traversed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy map with indexing starting from 0. No iteration is performed now, the function will be called when the result is traversed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-app" class="anchored"><a href="#val-app" class="anchor"></a><code><span><span class="keyword">val</span> app : <span><span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Applicative</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map" class="anchored"><a href="#val-fold_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_map : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy fold and map. No iteration is performed now, the function will be called when the result is traversed. The result is an iterator over the successive states of the fold. The final accumulator is discarded. Unlike <a href="#val-scan"><code>scan</code></a>, fold_map does not return the first accumulator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Append the two iterators; the result contains the elements of the first, then the elements of the second iterator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Flatten the iterator of iterators</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Monadic bind; each element is transformed to a sub-iterator which is then iterated on, before the next element is processed, and so on.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-app_interleave" class="anchored"><a href="#val-app_interleave" class="anchor"></a><code><span><span class="keyword">val</span> app_interleave : <span><span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-app"><code>app</code></a> but interleaves the values of the function and the argument iterators. See <a href="#val-interleave"><code>interleave</code></a> for more details.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map_interleave" class="anchored"><a href="#val-flat_map_interleave" class="anchor"></a><code><span><span class="keyword">val</span> flat_map_interleave : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>flat_map_interleave f seq</code> is similar to <code>flat_map f seq</code>, except that each sub-sequence is interleaved rather than concatenated in order. See <a href="#val-interleave"><code>interleave</code></a> for more details.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span>eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the given element, member of the iterator?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Take at most n elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Drop n elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>n-th element, or Not_found</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the iterator contains less than <code>n</code> arguments</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take_nth" class="anchored"><a href="#val-take_nth" class="anchor"></a><code><span><span class="keyword">val</span> take_nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_nth n g</code> returns every element of <code>g</code> whose index is a multiple of <code>n</code>. For instance <code>take_nth 2 (1--10) |&gt; to_list</code> will return <code>[1;3;5;7;9]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Filter out elements that do not satisfy the predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Take elements while they satisfy the predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_while" class="anchored"><a href="#val-fold_while" class="anchor"></a><code><span><span class="keyword">val</span> fold_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span>[ `Stop <span>| `Continue</span> ]</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold elements until (<code>'a, `Stop</code>) is indicated by the accumulator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Drop elements while they satisfy the predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Maps some elements to 'b, drop the other ones</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_index" class="anchored"><a href="#val-zip_index" class="anchor"></a><code><span><span class="keyword">val</span> zip_index : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Zip elements with their index in the iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip" class="anchored"><a href="#val-unzip" class="anchor"></a><code><span><span class="keyword">val</span> unzip : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Unzip into two iterators, splitting each pair</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>partition p l</code> returns the elements that satisfy <code>p</code>, and the elements that do not satisfy <code>p</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the predicate true for all elements?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the predicate true for at least one element?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span>lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Minimum element, according to the given comparison function.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the iterator is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span>lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Maximum element, see <a href="#val-min"><code>min</code></a></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the iterator is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span>eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality of iterators.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span>cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Lexicographic comparison of iterators. If a iterator is a prefix of the other one, it is considered smaller.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find p e</code> returns the first element of <code>e</code> to satisfy <code>p</code>, or None.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_map f e</code> returns the result of <code>f</code> on the first element of <code>e</code> for which it returns <code>Some _</code>, or <code>None</code> otherwise.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>int <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Sum of all elements</p></div></div><h3 id="multiple-iterators"><a href="#multiple-iterators" class="anchor"></a>Multiple iterators</h3><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map on the two iterators. Stops once one of them is exhausted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on the two iterators. Stops once one of them is exhausted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold2" class="anchored"><a href="#val-fold2" class="anchor"></a><code><span><span class="keyword">val</span> fold2 : <span><span>( <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p>Fold the common prefix of the two iterators</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all2" class="anchored"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Succeeds if all pairs of elements satisfy the predicate. Ignores elements of an iterator if the other runs dry.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists2" class="anchored"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Succeeds if some pair of elements satisfy the predicate. Ignores elements of an iterator if the other runs dry.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_with" class="anchored"><a href="#val-zip_with" class="anchor"></a><code><span><span class="keyword">val</span> zip_with : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Combine common part of the gens (stops when one is exhausted)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip" class="anchored"><a href="#val-zip" class="anchor"></a><code><span><span class="keyword">val</span> zip : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Zip together the common part of the gens</p></div></div><h3 id="complex-combinators"><a href="#complex-combinators" class="anchor"></a>Complex combinators</h3><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Pick elements fairly in each sub-iterator. The merge of gens <code>e1, e2, ... </code> picks elements in <code>e1</code>, <code>e2</code>, in <code>e3</code>, <code>e1</code>, <code>e2</code> .... Once an iterator is empty, it is skipped; when they are all empty, and none remains in the input, their merge is also empty. For instance, <code>merge [1;3;5] [2;4;6]</code> will be, in disorder, <code>1;2;3;4;5;6</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersection" class="anchored"><a href="#val-intersection" class="anchor"></a><code><span><span class="keyword">val</span> intersection : <span>cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Intersection of two sorted iterators. Only elements that occur in both inputs appear in the output</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted_merge" class="anchored"><a href="#val-sorted_merge" class="anchor"></a><code><span><span class="keyword">val</span> sorted_merge : <span>cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Merge two sorted iterators into a sorted iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-round_robin" class="anchored"><a href="#val-round_robin" class="anchor"></a><code><span><span class="keyword">val</span> round_robin : <span>?n:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span></span></code></div><div class="spec-doc"><p>Split the iterator into <code>n</code> iterators in a fair way. Elements with <code>index = k mod n</code> with go to the k-th iterator. <code>n</code> default value is 2.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span><span class="keyword">val</span> interleave : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>interleave a b</code> yields an element of <code>a</code>, then an element of <code>b</code>, and so on. When one of the iterators is exhausted, this behaves like the other iterator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersperse" class="anchored"><a href="#val-intersperse" class="anchor"></a><code><span><span class="keyword">val</span> intersperse : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Put the separator element between all elements of the given iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product, in no predictable order. Works even if some of the arguments are infinite.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product3" class="anchored"><a href="#val-product3" class="anchor"></a><code><span><span class="keyword">val</span> product3 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product of three iterators, see product.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-product4" class="anchored"><a href="#val-product4" class="anchor"></a><code><span><span class="keyword">val</span> product4 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product of four iterators, see product.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-product5" class="anchored"><a href="#val-product5" class="anchor"></a><code><span><span class="keyword">val</span> product5 : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span> * <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product of five iterators, see product.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-product6" class="anchored"><a href="#val-product6" class="anchor"></a><code><span><span class="keyword">val</span> product6 : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span> * <span class="type-var">'e</span> * <span class="type-var">'f</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product of six iterators, see product.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-product7" class="anchored"><a href="#val-product7" class="anchor"></a><code><span><span class="keyword">val</span> product7 : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'g</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span> * <span class="type-var">'e</span> * <span class="type-var">'f</span> * <span class="type-var">'g</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product of seven iterators, see product.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cartesian_product" class="anchored"><a href="#val-cartesian_product" class="anchor"></a><code><span><span class="keyword">val</span> cartesian_product : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Produce the cartesian product of this sequence of sequences, by returning all the ways of picking one element per sequence. <b>NOTE</b> the order of the returned sequence is unspecified.</p><p>This assumes each sub-sequence is finite, and that the main sequence is also finite.</p><p>For example:</p><pre><code># cartesian_product [[1;2];[3];[4;5;6]] |&gt; sort =
[[1;3;4];[1;3;5];[1;3;6];[2;3;4];[2;3;5];[2;3;6]];;
# cartesian_product [[1;2];[];[4;5;6]] = [];;
# cartesian_product [[1;2];[3];[4];[5];[6]] |&gt; sort =
[[1;3;4;5;6];[2;3;4;5;6]];;</code></pre><p>invariant: <code>cartesian_product l = map_product_l id l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_product_l" class="anchored"><a href="#val-map_product_l" class="anchor"></a><code><span><span class="keyword">val</span> map_product_l : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_product_l f l</code> maps each element of <code>l</code> to a list of objects of type <code>'b</code> using <code>f</code>. We obtain <code>[l1;l2;...;ln]</code> where <code>length l=n</code> and <code>li : 'b list</code>. Then, it returns all the ways of picking exactly one element per <code>li</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group" class="anchored"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span>eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Group equal consecutive elements together.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq" class="anchored"><a href="#val-uniq" class="anchor"></a><code><span><span class="keyword">val</span> uniq : <span>eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Remove consecutive duplicate elements. Basically this is like <code>fun e -&gt; map List.hd (group e)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span>cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Sort according to the given comparison function. The iterator must be finite.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_uniq" class="anchored"><a href="#val-sort_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sort_uniq : <span>cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Sort and remove duplicates. The iterator must be finite.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chunks" class="anchored"><a href="#val-chunks" class="anchor"></a><code><span><span class="keyword">val</span> chunks : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>chunks n e</code> returns a iterator of arrays of length <code>n</code>, composed of successive elements of <code>e</code>. The last array may be smaller than <code>n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-permutations" class="anchored"><a href="#val-permutations" class="anchor"></a><code><span><span class="keyword">val</span> permutations : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Permutations of the list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-combinations" class="anchored"><a href="#val-combinations" class="anchor"></a><code><span><span class="keyword">val</span> combinations : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Combinations of given length. The ordering of the elements within each combination is unspecified. Example (ignoring ordering): <code>combinations 2 (1--3) |&gt; to_list = [[1;2]; [1;3]; [2;3]]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-power_set" class="anchored"><a href="#val-power_set" class="anchor"></a><code><span><span class="keyword">val</span> power_set : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>All subsets of the iterator (in no particular order). The ordering of the elements within each subset is unspecified.</p></div></div><h3 id="relational-combinators"><a href="#relational-combinators" class="anchor"></a>Relational combinators</h3><div class="odoc-spec"><div class="spec module-type" id="module-type-HashedType" class="anchored"><a href="#module-type-HashedType" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> HashedType</span><span> = <span class="xref-unresolved">Stdlib</span>.Hashtbl.HashedType</span></code></div><div class="spec-doc"><p>A type that can be compared and hashed. invariant: for any <code>x</code> and <code>y</code>, if <code>equal x y</code> then <code>hash x=hash y</code> must hold.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-group_by" class="anchored"><a href="#val-group_by" class="anchor"></a><code><span><span class="keyword">val</span> group_by : 
  <span><span>(<span class="keyword">module</span> <a href="module-type-HashedType/index.html">HashedType</a> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>project:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'key</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Group together elements that project onto the same key, ignoring their order of appearance. The order of each resulting list is unspecified.</p><p>This function needs to consume the whole input before it can emit anything.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_by_fold" class="anchored"><a href="#val-group_by_fold" class="anchor"></a><code><span><span class="keyword">val</span> group_by_fold : 
  <span><span>(<span class="keyword">module</span> <a href="module-type-HashedType/index.html">HashedType</a> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>project:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>fold:<span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'key</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Group together elements that project onto the same key, folding them into some aggregate of type <code>'b</code> as they are met. This is the most general version of the &quot;group_by&quot; functions.</p><p>This function needs to consume the whole input before it can emit anything.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_count" class="anchored"><a href="#val-group_count" class="anchor"></a><code><span><span class="keyword">val</span> group_count : <span><span>(<span class="keyword">module</span> <a href="module-type-HashedType/index.html">HashedType</a> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * int)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map each distinct element to its number of occurrences in the whole seq. Similar to <code>group_by_fold hash_key ~project:(fun x-&gt;x) ~fold:(fun a _-&gt;a+1) ~init:0 seq</code>.</p><p>This function needs to consume the whole input before it can emit anything.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join_by" class="anchored"><a href="#val-join_by" class="anchor"></a><code><span><span class="keyword">val</span> join_by : 
  <span><span>(<span class="keyword">module</span> <a href="module-type-HashedType/index.html">HashedType</a> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>project_left:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>project_right:<span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>merge:<span>( <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join_by ~project_left ~project_right ~merge a b</code> takes every pair of elements <code>x</code> from <code>a</code> and <code>y</code> from <code>b</code>, and if they map onto the same key <code>k</code> by <code>project_left</code> and <code>project_right</code> respectively, and if <code>merge k x y = Some res</code>, then it yields <code>res</code>.</p><p>If <code>merge k x y</code> returns <code>None</code>, the combination of values is discarded.</p><p>This function works with infinite inputs, it does not have to consume the whole input before yielding elements.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join_by_fold" class="anchored"><a href="#val-join_by_fold" class="anchor"></a><code><span><span class="keyword">val</span> join_by_fold : 
  <span><span>(<span class="keyword">module</span> <a href="module-type-HashedType/index.html">HashedType</a> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>project_left:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>project_right:<span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>init:<span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span>merge:<span>( <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join_by_fold ~project_left ~project_right ~init ~merge a b</code> takes every pair of elements <code>x</code> from <code>a</code> and <code>y</code> from <code>b</code>, and if they map onto the same key <code>k</code> by <code>project_left</code> and <code>project_right</code> respectively, it fold <code>x</code> and <code>y</code> into the accumulator for this key (which starts at <code>init</code>).</p><p>This function consumes both inputs entirely before it emits anything.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><h3 id="basic-conversion-functions"><a href="#basic-conversion-functions" class="anchor"></a>Basic conversion functions</h3><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Enumerate elements of the list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>non tail-call trasnformation to list, in the same order</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_rev_list" class="anchored"><a href="#val-to_rev_list" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Tail call conversion to list, in reverse order (more efficient)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_array" class="anchored"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Convert the iterator to an array (not very efficient). The iterator must be memoized, as it's traversed twice.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array" class="anchored"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterate on (a slice of) the given array</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_gen" class="anchored"><a href="#val-of_gen" class="anchor"></a><code><span><span class="keyword">val</span> of_gen : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build a functional iterator from a mutable, imperative generator. The result is properly memoized and can be iterated on several times, as a normal functional value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_gen_transient" class="anchored"><a href="#val-of_gen_transient" class="anchor"></a><code><span><span class="keyword">val</span> of_gen_transient : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build a functional iterator from a mutable, imperative generator. Note that the resulting iterator is not going to be really functional because the underlying generator can be consumed only once. Use <a href="#val-memoize"><code>memoize</code></a> to recover the proper semantics, or use <a href="#val-of_gen"><code>of_gen</code></a> directly.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_gen" class="anchored"><a href="#val-to_gen" class="anchor"></a><code><span><span class="keyword">val</span> to_gen : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Build a mutable iterator that traverses this functional iterator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterate on bytes of the string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert into a string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer" class="anchored"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Traverse the iterator and writes its content to the buffer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_iter" class="anchored"><a href="#val-to_iter" class="anchor"></a><code><span><span class="keyword">val</span> to_iter : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-iter">iter</a></span></span></code></div><div class="spec-doc"><p>Iterate on the whole sequence.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_string" class="anchored"><a href="#val-concat_string" class="anchor"></a><code><span><span class="keyword">val</span> concat_string : <span>sep:string <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>concat_string ~sep s</code> concatenates all strings of <code>i</code>, separated with <code>sep</code>. The iterator must be memoized.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lines" class="anchored"><a href="#val-lines" class="anchor"></a><code><span><span class="keyword">val</span> lines : <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Group together chars belonging to the same line</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unlines" class="anchored"><a href="#val-unlines" class="anchor"></a><code><span><span class="keyword">val</span> unlines : <span><span>string <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Explode lines into their chars, adding a <code>'\n'</code> after each one</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Infix/index.html">Infix</a></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Integer range, inclusive</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--^)" class="anchored"><a href="#val-(--^)" class="anchor"></a><code><span><span class="keyword">val</span> (--^) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Integer range, exclusive in the right bound</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Monadic bind operator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infix map operator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;|=)" class="anchored"><a href="#val-(&gt;|=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;|=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infix map operator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*&gt;) : <span><span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-printer">printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-printer">printer</a></span></span></code></div><div class="spec-doc"><p>Pretty print the content of the iterator on a formatter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-memoize" class="anchored"><a href="#val-memoize" class="anchor"></a><code><span><span class="keyword">val</span> memoize : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Store content of the transient iterator in memory, to be able to iterate on it several times later.</p></div></div><h3 id="easy-interface-to-produce-iterators"><a href="#easy-interface-to-produce-iterators" class="anchor"></a>Easy interface to Produce Iterators</h3><div class="odoc-spec"><div class="spec module" id="module-Generator" class="anchored"><a href="#module-Generator" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Generator/index.html">Generator</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This interface is designed to make it easy to build complex streams of values in a way that resembles Python's generators (using &quot;yield&quot;).</p></div></div><div class="odoc-spec"><div class="spec module" id="module-IO" class="anchored"><a href="#module-IO" class="anchor"></a><code><span><span class="keyword">module</span> <a href="IO/index.html">IO</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-MONAD" class="anchored"><a href="#module-type-MONAD" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MONAD/index.html">MONAD</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Traverse" class="anchored"><a href="#module-Traverse" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Traverse/index.html">Traverse</a></span><span> (<a href="Traverse/argument-1-M/index.html">M</a> : <a href="module-type-MONAD/index.html">MONAD</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>